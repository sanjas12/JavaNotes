---
tags: Java/ООП
---
Объектно-ориентированное программирование - стиль программирования, при котором программы пишут, опираясь на реальные сущности и понятия и их характеристики. Программы разделяются на классы (шаблоны характеристик) для создания объекта. Объекты могут взаимодействовать между собой, как и в реальном мире.  Можно описывать абстрактные понятия и создавать связи между классами. ООП ускоряет написание кода и делает его более читаемым

3 составляющих каждого объекта
- идентичность
- состояние
- поведение

Основные принципы ООП
1. Инкапсуляция
2. Полиморфизм
3. Наследование
4. Абстракция

## Преимущества ООП
Повторное использование кода, возможность создавать расширяемые системы, код легко читается и пишется, т.к. разделен на модули, классы (которые описывают предметную область)
## Недостатки ООП
Снижение производительности и увеличение потребления памяти по сравнению с другими (процедурными языками программирования)
ООП требует распределения информации по множеству мелких инкапсулированных объектов, количество ссылок на эти объекты быстро растет, следовательно, падает производительность.
## Инкапсуляция
[[Инкапсуляция]]
## Наследование
[[Наследование]]
## Полиморфизм
[[Полиморфизм]]
## Абстракция
[[Абстракция]]
## Ассоциация агрегация
[[Ассоциация агрегация композиция]]
## Принципы написания кода
[[Принципы SOLID]]

Абстракция - это когда программист, увидев лес, не бросается создавать 100500 объектов со стволами, ветками и высотой, а думать начинает. Абстракция - это ДУМАТЬ. Вот лес, там куча палок с ветками. Окей, пусть ствол с ветками будет "дерево". Это **абстракция** Но у одних листья на ветках, а у других иголки. Создать поле "отросток" в классе "дерево" и значением "лист" и "иголка"? Нет, мы создадим "лиственное" extends "дерево" и "хвойное" extends "дерево". Это **наследование**. Добавим модификатор abstract в "дерево", "лиственное" и "хвойное", и ни один криворукий похмельный Вася, взятый по блату, не сможет создать объект этих типов. Потому что нет в природе объекта "дерево", которое просто "дерево", или "хвойное". Создадим класс "сосна", унаследованный от "хвойное" и наделим его какими-то особенными свойствами, чтобы отличить от "ёлки". И вот тогда Ваське остается только создать объект "сосна". Мы молодцы? Да, облегчили работу Васе. Уж объектов-то он сможет создать, сколько надо. Так что абстракция - это прежде всего умение продумать структуру будущей программы, чтобы её было с одной стороны труднее сломать, а с другой стороны проще каталогизировать. Добавим, что "дерево" должно уметь посчитать(). Это **интерфейс** А еще посадить(), спилить(), обрезать() и т.д. **Инкапсулируем** эти полезные вещи внутрь интерфейса. Посчитать все деревья? "дерево".посчитать() Посчитать все "хвойные" ? "хвойное".посчитать() Посчитать все сосны? "сосна".посчитать() p.s. При создании класса "сосна" компилятор напомнит: мы обязаны рассказать ему, а как же именно мы должны посчитать количество сосен (посадить, спилить, обрезать). И для класса "ёлка" тоже. Без разницы, какой класс, метод все время будет называться одинаково ( "посчитать", например ). Благодаря **полиморфизму** по одинаковому имени метода мы доберемся до нижнего уровня - класса. А благодаря **дженерикам** - сделаем это для всех деревьев